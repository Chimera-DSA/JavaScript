<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: linked-list.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: linked-list.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>class LinkedNode {
  val;
  next;
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class LinkedList {
  head;
  constructor() {
    this.head = null;
  }

  append(val) {
    const node = new LinkedNode(val);
    let head = this.head;
    while (head != null) {
      head = head.next;
    }
    head.next = node;
  }
}

class LinkedListWithHead {
  head;
  tail;
  constructor() {
    this.head = new LinkedNode(null);
    this.tail = null;
  }

  append(val) {
    const node = new LinkedNode(val);
    let head = this.head;
    while (head.next != null) {
      head = head.next;
    }
    head.next = node;
  }
}

/**
 * @description
 * 牛客题目：BM10 - 两个链表的第一个公共结点 - 简单
 *
 * Leetcode题目：面试题 02.07. 链表相交 - 简单
 *
 * 考研真题：2012统考真题
 *
 * 时间复杂度：O（m + n）
 *  m：链表一的长度
 *  n：链表二的长度
 *
 * 空间复杂度：O（1）
 *
 * @param {LinkedNode} head1 链表一的头指针
 * @param {LinkedNode} head2 链表二的头指针
 * @returns {LinkedNode} 第一个公共结点
 */
function findFirstCommonNode(head1, head2) {
  let h1 = head1;
  let h2 = head2;

  while (h1 !== h2) {
    h1 === null ? (h1 = head2) : (h1 = h1.next);
    h2 === null ? (h2 = head1) : (h2 = h2.next);
  }

  return h1;
}

/**
 * @description
 * Leetcode题目：面试题 02.02. 返回倒数第 k 个节点 - 简单
 *
 * 考研真题：2009统考真题
 *
 * @param {LinkedNode} head 链表的头指针
 * @param {number} k 倒数第k个结点
 * @returns {number} 第k个结点的值
 */
function kthToLast(head, k) {
  let newHead = reverseList(head);
  let count = 1;

  while (newHead !== null) {
    if (count === k) {
      return newHead.val;
    }
    count += 1;
    newHead = newHead.next;
  }
}

/**
 * @description
 * Leetcode题目：LCR 024. 反转链表 - 简单
 *
 * @param {LinkedNode} head 链表头结点
 * @returns {LinkedNode} 新的链表头结点
 */
function reverseList(head) {
  let pre = null;
  while (head !== null) {
    let next = head.next;
    head.next = pre;
    pre = head;
    head = next;
  }
  return pre;
}

/**
 * @description
 * Leetcode题目：143. 重排链表 - 中等
 *
 * 考研真题：2019年统考真题
 *
 * @param {LinkedNode} head 链表头指针
 * @returns {LinkedNode} 新的头指针
 */
function reorderList(head) {}

/**
 * 链表模块
 * @module
 */
module.exports = {
  LinkedNode,
  LinkedList,
  LinkedListWithHead,
  findFirstCommonNode,
  reverseList,
  kthToLast,
  reorderList,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-linked-list_linked-list.html">linked-list/linked-list</a></li></ul><h3>Classes</h3><ul><li><a href="LinkedList.html">LinkedList</a></li></ul><h3>Global</h3><ul><li><a href="global.html#findFirstCommonNode">findFirstCommonNode</a></li><li><a href="global.html#kthToLast">kthToLast</a></li><li><a href="global.html#reorderList">reorderList</a></li><li><a href="global.html#reverseList">reverseList</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Fri Oct 13 2023 19:10:27 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
